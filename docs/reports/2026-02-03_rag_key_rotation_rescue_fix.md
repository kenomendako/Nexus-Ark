# Task Report: RAG API Key Rotation - Rescue Strategy Fix

## 概要
RAG検索において、ユーザーが有料キー（Paid Key）を指定したにも関わらず `429 RESOURCE_EXHAUSTED` エラーが発生し、さらにAPIキーのローテーションが機能せずに失敗する問題に対処しました。

## 原因の特定
1. **枯渇状態の永続化**: システムはAPIキーが一度でも429エラーを返すと「枯渇（Exhausted）」とマークし、`.gemini_key_states.json` に保存して一定時間（デフォルト1時間）再利用を禁止します。
2. **デッドロック**: 
    - ユーザーが指定したPaidキー（`kenokaicoo`）は、以前の何らかの処理（または誤検知）により既に「枯渇」とマークされていました。
    - システムはPaidキーの使用を回避し、自動的に共通プールのキー（`menkenongi`など）にフォールバックしました。
    - しかし、共通プールのキーも「枯渇」状態（Free枠の上限到達）でした。
    - 結果として、`get_next_available_gemini_key` が「利用可能なキーなし（None）」を返し、検索が失敗しました。つまり、全てのキーが一時的にロックされた「デッドロック状態」に陥っていました。

## 修正内容: 救済措置 (Rescue Strategy) の導入
`config_manager.py` のキー選択ロジックを改良し、**「全てのキーが枯渇している場合」の救済フェーズ**を追加しました。

- **変更前**: 全てのキーが枯渇している場合、`None` を返し処理を中断（エラー終了）。
- **変更後**: 
    - 全てのキーが枯渇している場合、**「枯渇してから最も時間が経過しているキー（Oldest Exhausted Key）」** を特定します。
    - そのキーを「救済（Rescue）」し、強制的に再試行候補として返します。
    - これにより、1時間のロック解除を待たずに、回復している可能性のあるキーで処理を継続できます。特にPaidキーは回復が早いため、優先的に再利用される可能性が高まります。

## 検証結果
検証スクリプト (`debug_rotation_logic.py`) により以下のシナリオを確認しました：
1. **シナリオA**: Freeキーが枯渇し、Paidキーも枯渇している状態で、Freeキーでのアクセス失敗によりローテーションが発生した場合。
    - -> **Pass**: 除外リストに含まれないPaidキーが救済され、返されました。
2. **シナリオB**: 全てのキーが枯渇している状態での新規リクエスト。
    - -> **Pass**: 最も古く枯渇したキー（回復の可能性が高いキー）が救済され、返されました。

## 結論
この修正により、システムがAPIキーの全滅判定によって完全に停止することはなくなり、常に回復の可能性が高いキーで粘り強くリトライを行うようになります。ユーザーがPaidキーを指定している場合も、このロジックにより（他のFreeキーが全滅していれば）確実にPaidキーが再試行されるようになります。
